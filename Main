#include <iostream>
#include <time.h>
#include <stdlib.h>
using namespace std;
//STRUCTS
struct sMazo{
    short carta;
    bool usado;
};
 struct sCarta{
 	short valor;
 	short palo;
 	short numRef;
 };
 struct Nodo{
 	sCarta info;
 	Nodo* sgt;
 };



//PROTOTIPOS
void inicMazo(sMazo[][10]);
void printMazo(sMazo[][10]);
short eligeCarta(sMazo[][10],short&,short&,short&);
void inicCJ(sCarta[]);
void mostrarCJ(sCarta[]);
void repartir(sMazo[][10],sCarta[],sCarta[],short&,short&,short&);
void InicioPartida(sMazo[][10], sCarta[], sCarta[], short&, short&, short&, Nodo*& ,sCarta);
Nodo* insertarAlFinal(int*&, int);
Nodo* insertaPrimero(Nodo*&, sCarta);
void eliminarNodo(Nodo*&, int);
Nodo* insertarOrdenado(Nodo*&, sCarta);
void mostrar(Nodo*&);



int main(){
	short posicCarta,
          filaCarta,
          colCarta;

	Nodo*Carta = NULL;
	sCarta CJ1[3]; //cartasjugador1
	sCarta CJ2[3];//cartasjugador2

    sMazo mazo[4][10];

    inicMazo(mazo);
	inicCJ(CJ1);
	inicCJ(CJ2);
    //cout << "Cartas Random sacada: " << eligeCarta(mazo,posicCarta,filaCarta,colCarta)<< endl;
    printMazo(mazo);
	repartir(mazo,CJ1,CJ2,posicCarta,filaCarta,colCarta);
	mostrarCJ(CJ1);
	mostrarCJ(CJ2);
    printMazo(mazo);
    cout << endl << endl << endl << endl;
    InicioPartida(mazo, CJ1, CJ2, posicCarta, filaCarta, colCarta, Carta.sgt, Carta.info);


    return 0;
};

// ---------------------------------------------------------------------------------------
void inicMazo(sMazo mazo[][10]){
    short i,
          j;
    for (i = 0; i < 4; i++){
        for (j = 0; j < 10; j++){
            if ( j < 7){
                mazo[i][j].carta = j+1;
                mazo[i][j].usado = false;
            }
            else{   // (Mate Pirchi) Hice esta division para que saltear los numeros 8 y 9, y aun asi usar los espacios 7 y 8 de la matriz
            mazo[i][j].carta = j+3;
            mazo[i][j].usado = false;
            }
        }
    };
}

// ---------------------------------------------------------------------------------------
short eligeCarta(sMazo mazo[][10],short& posicCarta,short& filaCarta, short& colCarta){

 	  srand(time(0));
    posicCarta= rand()%30 + 1;

 	 colCarta= rand()%10+1;
     filaCarta= rand()%4;
   /* filaCarta =(posicCarta/10);
    colCarta = posicCarta-(filaCarta*10);*/
	    while (mazo[filaCarta][colCarta].usado){
        //colCarta++;
         colCarta= rand()%10+1;
   	  	filaCarta= rand()%4;
       ;
        if (colCarta >= 10){
            colCarta = 0;
            //filaCarta++;
            filaCarta= rand()%4;

            if (filaCarta >= 4){
                filaCarta = 0;
            }
        }
    }

    mazo[filaCarta][colCarta].usado = true;
    return mazo[filaCarta][colCarta].carta;
}

// ---------------------------------------------------------------------------------------
void printMazo(sMazo mazo[][10]){
    short i,
          j;

    for (i = 0; i < 4; i++){
        for (j = 0; j < 10; j++){
            cout << mazo[i][j].carta << " ";
        }
        cout << endl;
    }

    cout << endl <<"Fue usado?" << endl;
    for (i = 0; i < 4; i++){
        for (j = 0; j < 10; j++){
            cout <<j+1 + (i*10) << ") "<< mazo[i][j].usado << "  ";
        }
        cout << endl;
    }
}
//-------------------------------------------------------------------------------------------------

void repartir(sMazo mazo[][10],sCarta c1[], sCarta c2[],short&posicCarta,short& filaCarta, short& colCarta){
	int i=0;
	for(i; i<3 ; i++){
	eligeCarta(mazo,posicCarta,filaCarta,colCarta);
	c1[i].numRef= mazo[filaCarta][colCarta].carta;
	c1[i].palo = filaCarta;
	c1[i].valor = colCarta+1;

	eligeCarta(mazo,posicCarta,filaCarta,colCarta);
	c2[i].numRef= mazo[filaCarta][colCarta].carta;
	c2[i].palo = filaCarta;
	c2[i].valor = colCarta+1;

	}
}
//----------------------------------------------------------------------------------------------------------

void inicCJ(sCarta C[]){
	int i=0;
	for (i; i< 3; i++){
		C[i].valor=0;
		C[i].palo=0;
		C[i].numRef=0;
	}
}
//----------------------------------------------------------------------------------------------------------

void mostrarCJ(sCarta C[]){
	int i=0;
	for (i; i<3 ; i++){
		cout<<"numRef  "<<C[i].numRef<< endl;
		cout<<"palo "<<C[i].palo<< endl;
	//	cout<<"valor"<<C[i].valor<< endl;
	}
}
//hacer switch de los palos

//------------------------------------------------------------------------------------------------------

void InicioPartida(sMazo mazo[][10],sCarta c1[], sCarta c2[],short&posicCarta,short& filaCarta, short& colCarta,Nodo*& lista,sCarta info){
    int i;
    sCarta CartaActual;
    eligeCarta(mazo,posicCarta,filaCarta,colCarta);
    CartaActual.numRef= mazo[filaCarta][colCarta].carta;
	CartaActual.palo = filaCarta;
	CartaActual.valor = colCarta+1;
    insertaPrimero(lista,info);//insertainicio
	/*	CartaActual.numRef= 0;
		CartaActual.palo = 0;
		CartaActual.valor = 0;	*/
    for (i; i<3 ; i++){
		eligeCarta(mazo,posicCarta,filaCarta,colCarta);	//insertaordenado;
		CartaActual.numRef= mazo[filaCarta][colCarta].carta;
		CartaActual.palo = filaCarta;
		CartaActual.valor = colCarta+1;
		insertarOrdenado(lista,info);
	/*	CartaActual.numRef= 0;
		CartaActual.palo = 0;
		CartaActual.valor = 0;	*/
}
//primera parte volcar datos del mazo en nodos y agregarlos a la lista
repartir(mazo,c1,c2,posicCarta,filaCarta,colCarta);//segunda parte utilizar la funcion repartir
}

//------------------------------------------------------------------------------------------------------
//funciones bÃ¡sicas de listas

Nodo* insertarAlFinal(Nodo*& l, sCarta x){

 Nodo* nuevo = new Nodo();
 nuevo->info = x;
 nuevo->sgt = NULL;
 if( l==NULL ) {
 l = nuevo; }
 else {
 Nodo* aux = l;
 while(aux->sgt!=NULL )
 aux = aux->sgt;

 aux->sgt = nuevo;
 }
return nuevo;
}

//------------------------------------------------------------------------------------------------------
Nodo * insertaPrimero(Nodo*& l, sCarta x){
 Nodo* p = new Nodo();
 p ->info = x;
 p->sgt = l;
 l = p;
 return p;
}

//------------------------------------------------------------------------------------------------------

/*eliminarNodo elimina un nodo con un valor dado si lo encuentra*/
void eliminarNodo(Nodo*& l, sCarta v){
    Nodo* actual = l;
    Nodo* ant = NULL;

    while( actual!=NULL && (actual->info.numRef != v.numRef) ) {
        ant = actual;
        actual = actual->sgt;
    }
    if(actual->info.numRef != v.numRef ){ //no lo encontro
        cout << endl <<"ERROR No se encontro la Carta" << endl;
        return;
    }

    if( ant != NULL ){//si no es el primer nodo
        ant->sgt = actual->sgt;
    }
    else{//si se elimina el primero
        l = actual->sgt;//actualiza puntero al inicio
    }

    delete actual;
    return;
}

//------------------------------------------------------------------------------------------------------

//Insertar ordenado
Nodo* insertarOrdenado(Nodo*& l, sCarta v){
    Nodo* nuevo = new Nodo();
    nuevo->info = v;
    nuevo->sgt = NULL;
    Nodo* ant = NULL;
    Nodo* actual = l;

    while( actual!=NULL && actual->info.numRef <v.numRef ) {
        ant = actual;
        actual = actual->sgt;
    }
    if( ant==NULL ){
        l = nuevo;
    }
    else{
        ant->sgt = nuevo;
        nuevo->sgt = actual;
    }
 return nuevo;
}
//Version 2 Eliminando el nodo luego de mostrar
/*void mostrar(Nodo* & l) {
 while( l )
 cout << pop(l) << endl;
 return;
}*/
