
#include <iostream>
#include <time.h>
#include <stdlib.h>
#include <cstring>
using namespace std;
typedef char str6[7];

//STRUCTS
struct sMazo{
    short carta;
    bool usado;
};
 struct sCarta{
 	short valor;
 	str6 palo;
 	short numRef;
 };
 struct Nodo{
 	sCarta dato;
 	Nodo* siguiente;
 };



//PROTOTIPOS
void inicMazo(sMazo[][10]);
void printMazo(sMazo[][10]);
short eligeCarta(sMazo[][10],short&,short&,short&);
void inicCJ(sCarta[]);
void definePalo(short, str6);
void mostrarCJ(sCarta[]);
void repartir(sMazo[][10],sCarta[],sCarta[],short&,short&,short&);
void InicioPartida(sMazo[][10], sCarta[], sCarta[], short&, short&, short&, Nodo*& );
void insertarEnLista(Nodo*&,sCarta);
void mostrarListado(Nodo *);
void  ordenarPorBurbuja(sCarta[], short);

int main(){
	short posicCarta,
          filaCarta,
          colCarta;

	Nodo*punteroListaCarta = NULL;
	Nodo*punteroMazoSecJ1 = NULL;
	Nodo*punteroMazoSecJ2 = NULL;
	
	sCarta CJ1[3]; //cartasjugador1
	sCarta CJ2[3];//cartasjugador2

    sMazo mazo[4][10];

    inicMazo(mazo);
	inicCJ(CJ1);
	inicCJ(CJ2);
    //cout << "Cartas Random sacada: " << eligeCarta(mazo,posicCarta,filaCarta,colCarta)<< endl;
    printMazo(mazo);
	repartir(mazo,CJ1,CJ2,posicCarta,filaCarta,colCarta);
	mostrarCJ(CJ1);
	mostrarCJ(CJ2);
    printMazo(mazo);
    cout << endl << endl << endl << endl;
    InicioPartida(mazo, CJ1, CJ2, posicCarta, filaCarta, colCarta, *&punteroListaCarta);
    cout << "la mesa tiene " << endl;
	mostrarListado(punteroListaCarta);

    return 0;
};

// ---------------------------------------------------------------------------------------
void inicMazo(sMazo mazo[][10]){
    short i,
          j;
    for (i = 0; i < 4; i++){
        for (j = 0; j < 10; j++){
            if ( j < 7){
                mazo[i][j].carta = j+1;
                mazo[i][j].usado = false;
            }
            else{   // (Mate Pirchi) Hice esta division para que saltear los numeros 8 y 9, y aun asi usar los espacios 7 y 8 de la matriz
            mazo[i][j].carta = j+3;
            mazo[i][j].usado = false;
            }
        }
    };
}

short eligeCarta(sMazo mazo[][10],short& posicCarta,short& filaCarta, short& colCarta){

 	  srand(time(0));
    posicCarta= rand()%30 + 1;

 	 colCarta= rand()%10+1;
     filaCarta= rand()%4;
   /* filaCarta =(posicCarta/10);
    colCarta = posicCarta-(filaCarta*10);*/
	    while (mazo[filaCarta][colCarta].usado){
        //colCarta++;
         colCarta= rand()%10+1;
   	  	filaCarta= rand()%4;
       ;
        if (colCarta >= 10){
            colCarta = 0;
            //filaCarta++;
            filaCarta= rand()%4;

            if (filaCarta >= 4){
                filaCarta = 0;
            }
        }
    }

    mazo[filaCarta][colCarta].usado = true;
    return mazo[filaCarta][colCarta].carta;
}

void printMazo(sMazo mazo[][10]){
    short i,
          j;

    for (i = 0; i < 4; i++){
        for (j = 0; j < 10; j++){
            cout << mazo[i][j].carta << " ";
        }
        cout << endl;
    }

    cout << endl <<"Fue usado?" << endl;
    for (i = 0; i < 4; i++){
        for (j = 0; j < 10; j++){
            cout <<j+1 + (i*10) << ") "<< mazo[i][j].usado << "  ";
        }
        cout << endl;
    }
}

void repartir(sMazo mazo[][10],sCarta c1[], sCarta c2[],short&posicCarta,short& filaCarta, short& colCarta){
	int i=0;
	for(i; i<3 ; i++){
        eligeCarta(mazo,posicCarta,filaCarta,colCarta);
        c1[i].numRef= mazo[filaCarta][colCarta].carta;
        definePalo(filaCarta, c1[i].palo);
        c1[i].valor = colCarta+1;

	    eligeCarta(mazo,posicCarta,filaCarta,colCarta);
    	c2[i].numRef= mazo[filaCarta][colCarta].carta;
	    definePalo(filaCarta, c2[i].palo);
    	c2[i].valor = colCarta+1;

	}
	ordenarPorBurbuja(c1,3);
    ordenarPorBurbuja(c2,3);
	
}

void inicCJ(sCarta C[]){
	int i=0;
	for (i; i< 3; i++){
		C[i].valor=0;
		strcpy(C[i].palo, "Vacio");
		C[i].numRef=0;
	}
}

void mostrarCJ(sCarta C[]){
	int i=0;
	for (i; i<3 ; i++){
		cout<<"numRef  "<<C[i].numRef<< endl;
		cout<<"palo "<<C[i].palo<< endl;
	//	cout<<"valor"<<C[i].valor<< endl;
	}
}

void definePalo(short palo, str6 paloCarta){ //Le das el numero de la FILA y la VARIABLE donde GUARDAR el nombre del palo

    switch (palo){
        case 0:
            strcpy(paloCarta, "oro");
            break;
        case 1:
            strcpy(paloCarta, "copa");
            break;
        case 2:
            strcpy(paloCarta, "espada");
            break;
        case 3:
            strcpy(paloCarta, "basto");
            break;
        default:
            cout << "ERROR PALO INVALIDO, FILA NO ES NI 0, 1, 2 O 3";
    }
}

void InicioPartida(sMazo mazo[][10],sCarta c1[], sCarta c2[],short&posicCarta,short& filaCarta, short& colCarta,Nodo*& punteroListaCarta){
 	 sCarta CartaActual;
    for (int i=0; i<4 ; i++){
		eligeCarta(mazo,posicCarta,filaCarta,colCarta);
		CartaActual.numRef= mazo[filaCarta][colCarta].carta;
		definePalo(filaCarta, CartaActual.palo);
		CartaActual.valor = colCarta+1;
		insertarEnLista(punteroListaCarta,CartaActual);
    }//primera parte volcar datos del mazo en nodos y agregarlos a la lista
    repartir(mazo,c1,c2,posicCarta,filaCarta,colCarta);//segunda parte utilizar la funcion repartir
}

void insertarEnLista(Nodo *&punteroListaCarta, sCarta CartaActual){//insertaOrdenado
    Nodo *nuevo, *antecesor, *aux;
    nuevo = new Nodo;
    nuevo->dato = CartaActual;
    aux = punteroListaCarta;

    while (aux != NULL && aux->dato.valor < CartaActual.valor)
    {
        antecesor = aux;
        aux = aux->siguiente;
    }

    nuevo->siguiente = aux;

    if (aux != punteroListaCarta){


        antecesor->siguiente = nuevo;
    }
    else
    {
        punteroListaCarta = nuevo;
    }
}

void mostrarListado(Nodo *punteroListaCarta){
    Nodo *aux = punteroListaCarta;

    while (aux != NULL){
        cout <<"valor "<< aux->dato.valor  ;
        cout << " palo " << aux-> dato.palo  ;
        cout << " Num Ref " << aux -> dato.numRef ;
        cout << endl;
        aux = aux->siguiente;
    }
}

Nodo* buscarCarta(Nodo* punteroListaCarta, sCarta cartaBuscada) {
    Nodo* aux = punteroListaCarta;

    while (aux != NULL && aux->dato.numRef != cartaBuscada.numRef) {
        aux = aux->siguiente;
    }

    return aux;
}

Nodo* buscarMejorCarta(Nodo* punteroListaCarta, sCarta cartaBuscada) {
    Nodo* aux = punteroListaCarta;

    while (aux != NULL && !(aux->dato.numRef < cartaBuscada.numRef)) {
        aux = aux->siguiente;
    }

    return aux;
}

bool eliminarCarta(Nodo*& punteroListaCarta, sCarta cartaBuscada) {
    Nodo* aux, *antecesor;
    aux = punteroListaCarta;

    while (aux != NULL && aux->dato.numRef != cartaBuscada.numRef) {
        antecesor = aux;
        aux = aux->siguiente;
    }

    if (aux != NULL) {
        if (aux == punteroListaCarta) {
            punteroListaCarta = aux->siguiente;
        } else {
            antecesor->siguiente = aux->siguiente;
        }

        delete aux;
        return true;
    } else {
        return false;
    }
}

Nodo* buscarInsertarCarta(Nodo*& punteroListaCarta, sCarta cartaBuscada) {
    Nodo* aux = punteroListaCarta, *antecesor;

    while (aux != NULL && !(aux->dato.numRef < cartaBuscada.numRef)) {
        antecesor = aux;
        aux = aux->siguiente;
    }

    if (aux != NULL && aux->dato.numRef == cartaBuscada.numRef) {
        return aux;
    } else {
        Nodo* nuevo = new Nodo;
        nuevo->dato = cartaBuscada;
        nuevo->siguiente = aux;

        if (aux != punteroListaCarta) {
            antecesor->siguiente = nuevo;
        } else {
            punteroListaCarta = nuevo;
        }

        return nuevo;
    }
}
void Interfaz(){ //pasar por ref vector 
	int posCarta;
	char accion;
	InicioPartida(mazo, CJ1, CJ2, posicCarta, filaCarta, colCarta, *&punteroListaCarta);	//mostrar mesa y vector jugador 1
	mostrarListado(punteroListaCarta);
	mostrarCJ(CJ1);
	cout << "Seleccione una Carta segun la posicion" << endl;
	cin >> posCarta;
	cout << "¿Qué operacion desea realizar con esta carta?" <<endl;
	cout << "Si desea levantar inserte A o si desea tirar la carta inserte B" << endl;
	cin >> accion;
	switch (accion){
		case 'A': 	
					break;
		case 'B': 	insertarEnLista(punteroListaCarta,C1[posCarta-1]);
					C1[posCarta-1].numRef=0;
					break;
		default: break;
	}
	// menu preguntando que va a hacer si levantar o tirar
	// en caso de que levante debe elegir cartas con un menu que cierre cuantas cartas se levanta,  la condicion de que de 15 la suma de los valores de los nodo
	// en caso de tirar invoca la funcion inserta nodo y agrega la carta sobre la mesa
	//borrar todo en la pantalla
	//mostrar mesa y v2
	//ofrecer lo mismo para v2 
	
}*/





